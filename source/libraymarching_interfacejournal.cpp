/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.4.0.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Ray Marching Library. It provides an automatic Journaling mechanism for the library implementation.

Interface version: 0.9.0

*/


#include <string>
#include <sstream>
#include <iomanip>

#include "libraymarching_interfacejournal.hpp"
#include "libraymarching_interfaceexception.hpp"


std::string LibRayMarchingHandleToHex (LibRayMarchingHandle pHandle)
{
	std::stringstream stream;
	stream << std::setfill('0') << std::setw(sizeof(LibRayMarching_uint64) * 2)
		<< std::hex << (LibRayMarching_uint64) pHandle;
	return stream.str();
}

CLibRayMarchingInterfaceJournalEntry::CLibRayMarchingInterfaceJournalEntry(CLibRayMarchingInterfaceJournal * pJournal, std::string sClassName, std::string sMethodName, LibRayMarchingHandle pInstanceHandle)
	: m_sClassName(sClassName), m_sMethodName(sMethodName), m_pJournal (pJournal), m_nInitTimeStamp (0), m_nFinishTimeStamp (0), m_ErrorCode (LIBRAYMARCHING_SUCCESS)
{
	if (pJournal == nullptr)
		throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDPARAM);
	m_nInitTimeStamp = m_pJournal->getTimeStamp ();
	m_sInstanceHandle = LibRayMarchingHandleToHex (pInstanceHandle);
}

CLibRayMarchingInterfaceJournalEntry::~CLibRayMarchingInterfaceJournalEntry()
{
}

void CLibRayMarchingInterfaceJournalEntry::addParameter(const std::string & sName, const std::string & sParameterType, const std::string & sParameterValue)
{
	m_sParameters.push_back(std::make_pair(std::make_pair(sName, sParameterType), sParameterValue));
}

void CLibRayMarchingInterfaceJournalEntry::addResult(const std::string & sName, const std::string & sResultType, const std::string & sResultValue)
{
	m_sResultValues.push_back(std::make_pair(std::make_pair(sName, sResultType), sResultValue));
}

std::string CLibRayMarchingInterfaceJournalEntry::getXMLString()
{
	std::stringstream sStream;
	LibRayMarching_uint64 nDuration = 0;

	if (m_nFinishTimeStamp > m_nInitTimeStamp)
		nDuration = m_nFinishTimeStamp - m_nInitTimeStamp;

	sStream << "    <entry";
	if (m_sClassName != "")
		sStream << " class=\"" << m_sClassName << "\"";
	sStream << " method=\"" << m_sMethodName << "\"";
	if (m_ErrorCode != LIBRAYMARCHING_SUCCESS)
		sStream << " errorcode=\"" << m_ErrorCode << "\"";
	sStream << " timestamp=\"" << m_nInitTimeStamp << "\" duration=\"" << nDuration << "\">\n";

	if (m_sClassName != "")
		sStream << "        <instance handle=\"" << m_sInstanceHandle << "\" />\n";

	auto iParamIter = m_sParameters.begin();
	while (iParamIter != m_sParameters.end()) {
		sStream << "        <parameter name=\"" << iParamIter->first.first << "\" type=\"" << iParamIter->first.second << "\" value=\"" << iParamIter->second <<"\" />\n";
		iParamIter++;
	}

	auto iResultIter = m_sResultValues.begin();
	while (iResultIter != m_sResultValues.end()) {
		sStream << "        <result name=\"" << iResultIter->first.first << "\" type=\"" << iResultIter->first.second << "\" value=\"" << iResultIter->second << "\" />\n";
		iResultIter++;
	}

	sStream << "    </entry>\n";
	return sStream.str ();
}

void CLibRayMarchingInterfaceJournalEntry::writeSuccess()
{
	writeError(LIBRAYMARCHING_SUCCESS);
}

void CLibRayMarchingInterfaceJournalEntry::writeError(LibRayMarchingResult nErrorCode)
{
	m_ErrorCode = nErrorCode;
	m_nFinishTimeStamp = m_pJournal->getTimeStamp();
	m_pJournal->writeEntry(this);
}

void CLibRayMarchingInterfaceJournalEntry::addBooleanParameter(const std::string & sName, const bool bValue)
{
	addParameter (sName, "bool", std::to_string((int)bValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt8Parameter(const std::string & sName, const LibRayMarching_uint8 nValue)
{
	addParameter(sName, "uint8", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt16Parameter(const std::string & sName, const LibRayMarching_uint16 nValue)
{
	addParameter(sName, "uint16", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt32Parameter(const std::string & sName, const LibRayMarching_uint32 nValue)
{
	addParameter(sName, "uint32", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt64Parameter(const std::string & sName, const LibRayMarching_uint64 nValue)
{
	addParameter(sName, "uint64", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt8Parameter(const std::string & sName, const LibRayMarching_int8 nValue)
{
	addParameter(sName, "int8", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt16Parameter(const std::string & sName, const LibRayMarching_int16 nValue)
{
	addParameter(sName, "int16", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt32Parameter(const std::string & sName, const LibRayMarching_int32 nValue)
{
	addParameter(sName, "uint32", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt64Parameter(const std::string & sName, const LibRayMarching_int64 nValue)
{
	addParameter(sName, "int64", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addSingleParameter(const std::string & sName,  const LibRayMarching_single fValue)
{
	addParameter(sName, "single", std::to_string(fValue));
}

void CLibRayMarchingInterfaceJournalEntry::addDoubleParameter(const std::string & sName, const LibRayMarching_double dValue)
{
	addParameter(sName, "double", std::to_string(dValue));
}

void CLibRayMarchingInterfaceJournalEntry::addStringParameter(const std::string & sName, const char * pValue)
{
	if (pValue != nullptr) {
		addParameter(sName, "string", pValue);
	}
	else {
		addParameter(sName, "nullstring", "");
	}
}

void CLibRayMarchingInterfaceJournalEntry::addHandleParameter(const std::string & sName, const LibRayMarchingHandle pHandle)
{
	addParameter(sName, "handle", LibRayMarchingHandleToHex(pHandle));
}

void CLibRayMarchingInterfaceJournalEntry::addEnumParameter(const std::string & sName, const std::string & sEnumType, const LibRayMarching_uint32 nValue)
{
	addParameter(sName, "enum" + sEnumType, std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addBooleanResult(const std::string & sName, const bool bValue)
{
	addResult(sName, "bool", std::to_string((int)bValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt8Result(const std::string & sName, const LibRayMarching_uint8 nValue)
{
	addResult(sName, "uint8", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt16Result(const std::string & sName, const LibRayMarching_uint16 nValue)
{
	addResult(sName, "uint16", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt32Result(const std::string & sName, const LibRayMarching_uint32 nValue)
{
	addResult(sName, "uint32", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addUInt64Result(const std::string & sName, const LibRayMarching_uint64 nValue)
{
	addResult(sName, "uint64", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt8Result(const std::string & sName, const LibRayMarching_int8 nValue)
{
	addResult(sName, "int8", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt16Result(const std::string & sName, const LibRayMarching_int16 nValue)
{
	addResult(sName, "int16", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt32Result(const std::string & sName, const LibRayMarching_int32 nValue)
{
	addResult(sName, "uint32", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addInt64Result(const std::string & sName, const LibRayMarching_int64 nValue)
{
	addResult(sName, "int64", std::to_string(nValue));
}

void CLibRayMarchingInterfaceJournalEntry::addSingleResult(const std::string & sName,  const LibRayMarching_single fValue)
{
	addResult(sName, "single", std::to_string(fValue));
}

void CLibRayMarchingInterfaceJournalEntry::addDoubleResult(const std::string & sName, const LibRayMarching_double dValue)
{
	addResult(sName, "double", std::to_string(dValue));
}

void CLibRayMarchingInterfaceJournalEntry::addStringResult(const std::string & sName, const char * pValue)
{
	if (pValue != nullptr) {
		addResult(sName, "string", pValue);
	}
	else {
		addResult(sName, "nullstring", "");
	}
}

void CLibRayMarchingInterfaceJournalEntry::addHandleResult(const std::string & sName, const LibRayMarchingHandle pHandle)
{
	addResult(sName, "handle", LibRayMarchingHandleToHex(pHandle));
}

void CLibRayMarchingInterfaceJournalEntry::addEnumResult(const std::string & sName, const std::string & sEnumType, const LibRayMarching_uint32 nValue)
{
	addResult(sName, "enum" + sEnumType, std::to_string(nValue));
}


CLibRayMarchingInterfaceJournal::CLibRayMarchingInterfaceJournal (const std::string & sFileName)
	: m_sFileName (sFileName)
{
	m_StartTime = std::chrono::high_resolution_clock::now();
	m_Stream.open (sFileName, std::ios::out);
	m_Stream << "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n";
	m_Stream << "<journal library=\"LibRayMarching\" version=\"0.9.0\" xmlns=\"http://schemas.autodesk.com/components/LibRayMarching/0.9.0\">\n";
	m_Stream << "\n";

}

CLibRayMarchingInterfaceJournal::~CLibRayMarchingInterfaceJournal ()
{
	m_Stream << "</journal>\n";
}

PLibRayMarchingInterfaceJournalEntry CLibRayMarchingInterfaceJournal::beginClassMethod(const LibRayMarchingHandle pHandle, const std::string & sClassName, const std::string & sMethodName)
{
	return std::make_shared<CLibRayMarchingInterfaceJournalEntry>(this, sClassName, sMethodName, pHandle);
}

PLibRayMarchingInterfaceJournalEntry CLibRayMarchingInterfaceJournal::beginStaticFunction(const std::string & sMethodName)
{
	return std::make_shared<CLibRayMarchingInterfaceJournalEntry>(this, "", sMethodName, nullptr);
}

void CLibRayMarchingInterfaceJournal::writeEntry (CLibRayMarchingInterfaceJournalEntry * pEntry)
{
	if (pEntry == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

	std::string sXMLString = pEntry->getXMLString();
	m_Mutex.lock();
	try {
		m_Stream << sXMLString;
		m_Stream << "\n";

		m_Mutex.unlock();
	}
	catch (...) {
		m_Mutex.unlock();
	}
}

LibRayMarching_uint64 CLibRayMarchingInterfaceJournal::getTimeStamp ()
{
	auto currentTime = std::chrono::high_resolution_clock::now();
	if (m_StartTime < currentTime) {
		auto duration = currentTime - m_StartTime;
		auto milliSeconds = std::chrono::duration_cast<std::chrono::milliseconds> (duration);

		return (LibRayMarching_uint64) milliSeconds.count();
	}
	else {
		return 0;
	}

}

