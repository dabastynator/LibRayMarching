/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Ray Marching Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libraymarching_abi.hpp"
#include "libraymarching_interfaces.hpp"
#include "libraymarching_interfaceexception.hpp"

#include <map>

using namespace LibRayMarching::Impl;

LibRayMarchingResult handleLibRayMarchingException(IBaseClass * pIBaseClass, ELibRayMarchingInterfaceException & Exception)
{
	LibRayMarchingResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRayMarchingResult handleStdException(IBaseClass * pIBaseClass, std::exception & Exception)
{
	LibRayMarchingResult errorCode = LIBRAYMARCHING_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRayMarchingResult handleUnhandledException(IBaseClass * pIBaseClass)
{
	LibRayMarchingResult errorCode = LIBRAYMARCHING_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for BaseClass
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Primitive
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_primitive_identityposition(LibRayMarching_Primitive pPrimitive)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->IdentityPosition();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_translate(LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pTranslation)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->Translate(*pTranslation);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_rotate(LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pAxis, LibRayMarching_double dRadian)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->Rotate(*pAxis, dRadian);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_scale(LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pScale)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->Scale(*pScale);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_setmaterial(LibRayMarching_Primitive pPrimitive, const sLibRayMarchingMaterial * pMaterial)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->SetMaterial(*pMaterial);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_setglow(LibRayMarching_Primitive pPrimitive, const sLibRayMarchingGlow * pGlow)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->SetGlow(*pGlow);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_setsinusdistortion(LibRayMarching_Primitive pPrimitive, LibRayMarching_double dDistortionFactor, LibRayMarching_double dInterval)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitive;

	try {
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitive->SetSinusDistortion(dDistortionFactor, dInterval);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Sphere
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_sphere_getradius(LibRayMarching_Sphere pSphere, LibRayMarching_double * pRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pSphere;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ISphere* pISphere = dynamic_cast<ISphere*>(pIBaseClass);
		if (!pISphere)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pRadius = pISphere->GetRadius();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_sphere_setradius(LibRayMarching_Sphere pSphere, LibRayMarching_double dRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pSphere;

	try {
		ISphere* pISphere = dynamic_cast<ISphere*>(pIBaseClass);
		if (!pISphere)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pISphere->SetRadius(dRadius);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Capsule
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_capsule_getradius(LibRayMarching_Capsule pCapsule, LibRayMarching_double * pRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pRadius = pICapsule->GetRadius();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setradius(LibRayMarching_Capsule pCapsule, LibRayMarching_double dRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pICapsule->SetRadius(dRadius);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_getpoint1(LibRayMarching_Capsule pCapsule, sLibRayMarchingVector * pPoint1)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		if (pPoint1 == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pPoint1 = pICapsule->GetPoint1();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setpoint1(LibRayMarching_Capsule pCapsule, const sLibRayMarchingVector * pPoint1)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pICapsule->SetPoint1(*pPoint1);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_getpoint2(LibRayMarching_Capsule pCapsule, sLibRayMarchingVector * pPoint2)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		if (pPoint2 == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pPoint2 = pICapsule->GetPoint2();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setpoint2(LibRayMarching_Capsule pCapsule, const sLibRayMarchingVector * pPoint2)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCapsule;

	try {
		ICapsule* pICapsule = dynamic_cast<ICapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pICapsule->SetPoint2(*pPoint2);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Plane
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_plane_getnormal(LibRayMarching_Plane pPlane, sLibRayMarchingVector * pNormal)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPlane;

	try {
		if (pNormal == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IPlane* pIPlane = dynamic_cast<IPlane*>(pIBaseClass);
		if (!pIPlane)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pNormal = pIPlane->GetNormal();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_plane_setnormal(LibRayMarching_Plane pPlane, const sLibRayMarchingVector * pNormal)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPlane;

	try {
		IPlane* pIPlane = dynamic_cast<IPlane*>(pIBaseClass);
		if (!pIPlane)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPlane->SetNormal(*pNormal);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Box
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_box_getdimensions(LibRayMarching_Box pBox, sLibRayMarchingVector * pDimensions)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pBox;

	try {
		if (pDimensions == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBox* pIBox = dynamic_cast<IBox*>(pIBaseClass);
		if (!pIBox)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pDimensions = pIBox->GetDimensions();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_box_setdimensions(LibRayMarching_Box pBox, const sLibRayMarchingVector * pDimensions)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pBox;

	try {
		IBox* pIBox = dynamic_cast<IBox*>(pIBaseClass);
		if (!pIBox)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIBox->SetDimensions(*pDimensions);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Torus
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_torus_getbigradius(LibRayMarching_Torus pTorus, LibRayMarching_double * pBigRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pTorus;

	try {
		if (pBigRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ITorus* pITorus = dynamic_cast<ITorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pBigRadius = pITorus->GetBigRadius();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_setbigradius(LibRayMarching_Torus pTorus, LibRayMarching_double dBigRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pTorus;

	try {
		ITorus* pITorus = dynamic_cast<ITorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pITorus->SetBigRadius(dBigRadius);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_getsmallradius(LibRayMarching_Torus pTorus, LibRayMarching_double * pSmallRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pTorus;

	try {
		if (pSmallRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ITorus* pITorus = dynamic_cast<ITorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pSmallRadius = pITorus->GetSmallRadius();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_setsmallradius(LibRayMarching_Torus pTorus, LibRayMarching_double dSmallRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pTorus;

	try {
		ITorus* pITorus = dynamic_cast<ITorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pITorus->SetSmallRadius(dSmallRadius);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Cylinder
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_cylinder_getradius(LibRayMarching_Cylinder pCylinder, LibRayMarching_double * pRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCylinder;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ICylinder* pICylinder = dynamic_cast<ICylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pRadius = pICylinder->GetRadius();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_setradius(LibRayMarching_Cylinder pCylinder, LibRayMarching_double dRadius)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCylinder;

	try {
		ICylinder* pICylinder = dynamic_cast<ICylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pICylinder->SetRadius(dRadius);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_getheight(LibRayMarching_Cylinder pCylinder, LibRayMarching_double * pHeight)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCylinder;

	try {
		if (pHeight == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		ICylinder* pICylinder = dynamic_cast<ICylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pHeight = pICylinder->GetHeight();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_setheight(LibRayMarching_Cylinder pCylinder, LibRayMarching_double dHeight)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pCylinder;

	try {
		ICylinder* pICylinder = dynamic_cast<ICylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pICylinder->SetHeight(dHeight);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for QuaternionFractal
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_quaternionfractal_getquaternion(LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_double * pR, LibRayMarching_double * pI, LibRayMarching_double * pJ, LibRayMarching_double * pK)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pQuaternionFractal;

	try {
		if (!pR)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pI)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pJ)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pK)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IQuaternionFractal* pIQuaternionFractal = dynamic_cast<IQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIQuaternionFractal->GetQuaternion(*pR, *pI, *pJ, *pK);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_setquaternion(LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_double dR, LibRayMarching_double dI, LibRayMarching_double dJ, LibRayMarching_double dK)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pQuaternionFractal;

	try {
		IQuaternionFractal* pIQuaternionFractal = dynamic_cast<IQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIQuaternionFractal->SetQuaternion(dR, dI, dJ, dK);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_getiterations(LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_uint32 * pIterations)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pQuaternionFractal;

	try {
		if (pIterations == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IQuaternionFractal* pIQuaternionFractal = dynamic_cast<IQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pIterations = pIQuaternionFractal->GetIterations();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_setiterations(LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_uint32 nIterations)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pQuaternionFractal;

	try {
		IQuaternionFractal* pIQuaternionFractal = dynamic_cast<IQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIQuaternionFractal->SetIterations(nIterations);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for MengerSponge
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_mengersponge_getstepcount(LibRayMarching_MengerSponge pMengerSponge, LibRayMarching_uint32 * pStepCount)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pMengerSponge;

	try {
		if (pStepCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IMengerSponge* pIMengerSponge = dynamic_cast<IMengerSponge*>(pIBaseClass);
		if (!pIMengerSponge)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pStepCount = pIMengerSponge->GetStepCount();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_mengersponge_setstepcount(LibRayMarching_MengerSponge pMengerSponge, LibRayMarching_uint32 nStepCount)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pMengerSponge;

	try {
		IMengerSponge* pIMengerSponge = dynamic_cast<IMengerSponge*>(pIBaseClass);
		if (!pIMengerSponge)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIMengerSponge->SetStepCount(nStepCount);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PrimitiveGroup
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_primitivegroup_getprimitivecount(LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 * pCount)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pCount = pIPrimitiveGroup->GetPrimitiveCount();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_getprimitive(LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 nIndex, LibRayMarching_Primitive * pPrimitive)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		if (pPrimitive == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBasePrimitive(nullptr);
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pBasePrimitive = pIPrimitiveGroup->GetPrimitive(nIndex);

		*pPrimitive = (IBaseClass*)(pBasePrimitive);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_addprimitive(LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_Primitive pPrimitive)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		IBaseClass* pIBaseClassPrimitive = (IBaseClass *)pPrimitive;
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClassPrimitive);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitiveGroup->AddPrimitive(pIPrimitive);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_removeprimitive(LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 nIndex)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitiveGroup->RemovePrimitive(nIndex);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_setgroupaction(LibRayMarching_PrimitiveGroup pPrimitiveGroup, eLibRayMarchingGroupAction eGroupAction)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIPrimitiveGroup->SetGroupAction(eGroupAction);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_getgroupaction(LibRayMarching_PrimitiveGroup pPrimitiveGroup, eLibRayMarchingGroupAction * pGroupAction)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pPrimitiveGroup;

	try {
		if (pGroupAction == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<IPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pGroupAction = pIPrimitiveGroup->GetGroupAction();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for RayMarching
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_raymarching_getlightcount(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 * pCount)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pCount = pIRayMarching->GetLightCount();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getlight(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex, sLibRayMarchingVector * pPosition, sLibRayMarchingVector * pColor)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if (!pPosition)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pColor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->GetLight(nIndex, *pPosition, *pColor);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_addlight(LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingVector * pPosition, const sLibRayMarchingVector * pColor)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->AddLight(*pPosition, *pColor);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_deletelight(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->DeleteLight(nIndex);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getprimitivecount(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 * pCount)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pCount = pIRayMarching->GetPrimitiveCount();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getprimitive(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex, LibRayMarching_Primitive * pPrimitive)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if (pPrimitive == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBasePrimitive(nullptr);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pBasePrimitive = pIRayMarching->GetPrimitive(nIndex);

		*pPrimitive = (IBaseClass*)(pBasePrimitive);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_addprimitive(LibRayMarching_RayMarching pRayMarching, LibRayMarching_Primitive pPrimitive)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IBaseClass* pIBaseClassPrimitive = (IBaseClass *)pPrimitive;
		IPrimitive* pIPrimitive = dynamic_cast<IPrimitive*>(pIBaseClassPrimitive);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->AddPrimitive(pIPrimitive);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_removeprimitive(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->RemovePrimitive(nIndex);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setscreensize(LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nWidth, LibRayMarching_uint32 nHeight)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->SetScreenSize(nWidth, nHeight);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setviewport(LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingVector * pEye, const sLibRayMarchingVector * pDir, const sLibRayMarchingVector * pUp, LibRayMarching_double dFOV)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->SetViewport(*pEye, *pDir, *pUp, dFOV);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setbackground(LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingVector * pBackground, LibRayMarching_double dDistanceStart, LibRayMarching_double dDistanceEnd)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->SetBackground(*pBackground, dDistanceStart, dDistanceEnd);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setshaderproperties(LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingShaderProperties * pShaderProperties)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->SetShaderProperties(*pShaderProperties);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_renderscene(LibRayMarching_RayMarching pRayMarching)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->RenderScene();

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getcolorbuffer(LibRayMarching_RayMarching pRayMarching, const LibRayMarching_uint64 nColorBufferBufferSize, LibRayMarching_uint64* pColorBufferNeededCount, sLibRayMarchingColor * pColorBufferBuffer)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if ((!pColorBufferBuffer) && !(pColorBufferNeededCount))
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->GetColorBuffer(nColorBufferBufferSize, pColorBufferNeededCount, pColorBufferBuffer);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_renderpixel(LibRayMarching_RayMarching pRayMarching, LibRayMarching_double dX, LibRayMarching_double dY, sLibRayMarchingColor * pColor)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		if (pColor == nullptr)
		throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		*pColor = pIRayMarching->RenderPixel(dX, dY);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setprogresscallback(LibRayMarching_RayMarching pRayMarching, LibRayMarchingProgressCallback pProgressCallback)
{
	IBaseClass* pIBaseClass = (IBaseClass *)pRayMarching;

	try {
		IRayMarching* pIRayMarching = dynamic_cast<IRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		pIRayMarching->SetProgressCallback(pProgressCallback);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibRayMarchingResult _libraymarching_getprocaddress_internal(const char * pProcName, void ** ppProcAddress)
{
	static bool sbProcAddressMapHasBeenInitialized = false;
	static std::map<std::string, void*> sProcAddressMap;
	if (!sbProcAddressMapHasBeenInitialized) {
		sProcAddressMap["libraymarching_primitive_identityposition"] = (void*)&libraymarching_primitive_identityposition;
		sProcAddressMap["libraymarching_primitive_translate"] = (void*)&libraymarching_primitive_translate;
		sProcAddressMap["libraymarching_primitive_rotate"] = (void*)&libraymarching_primitive_rotate;
		sProcAddressMap["libraymarching_primitive_scale"] = (void*)&libraymarching_primitive_scale;
		sProcAddressMap["libraymarching_primitive_setmaterial"] = (void*)&libraymarching_primitive_setmaterial;
		sProcAddressMap["libraymarching_primitive_setglow"] = (void*)&libraymarching_primitive_setglow;
		sProcAddressMap["libraymarching_primitive_setsinusdistortion"] = (void*)&libraymarching_primitive_setsinusdistortion;
		sProcAddressMap["libraymarching_sphere_getradius"] = (void*)&libraymarching_sphere_getradius;
		sProcAddressMap["libraymarching_sphere_setradius"] = (void*)&libraymarching_sphere_setradius;
		sProcAddressMap["libraymarching_capsule_getradius"] = (void*)&libraymarching_capsule_getradius;
		sProcAddressMap["libraymarching_capsule_setradius"] = (void*)&libraymarching_capsule_setradius;
		sProcAddressMap["libraymarching_capsule_getpoint1"] = (void*)&libraymarching_capsule_getpoint1;
		sProcAddressMap["libraymarching_capsule_setpoint1"] = (void*)&libraymarching_capsule_setpoint1;
		sProcAddressMap["libraymarching_capsule_getpoint2"] = (void*)&libraymarching_capsule_getpoint2;
		sProcAddressMap["libraymarching_capsule_setpoint2"] = (void*)&libraymarching_capsule_setpoint2;
		sProcAddressMap["libraymarching_plane_getnormal"] = (void*)&libraymarching_plane_getnormal;
		sProcAddressMap["libraymarching_plane_setnormal"] = (void*)&libraymarching_plane_setnormal;
		sProcAddressMap["libraymarching_box_getdimensions"] = (void*)&libraymarching_box_getdimensions;
		sProcAddressMap["libraymarching_box_setdimensions"] = (void*)&libraymarching_box_setdimensions;
		sProcAddressMap["libraymarching_torus_getbigradius"] = (void*)&libraymarching_torus_getbigradius;
		sProcAddressMap["libraymarching_torus_setbigradius"] = (void*)&libraymarching_torus_setbigradius;
		sProcAddressMap["libraymarching_torus_getsmallradius"] = (void*)&libraymarching_torus_getsmallradius;
		sProcAddressMap["libraymarching_torus_setsmallradius"] = (void*)&libraymarching_torus_setsmallradius;
		sProcAddressMap["libraymarching_cylinder_getradius"] = (void*)&libraymarching_cylinder_getradius;
		sProcAddressMap["libraymarching_cylinder_setradius"] = (void*)&libraymarching_cylinder_setradius;
		sProcAddressMap["libraymarching_cylinder_getheight"] = (void*)&libraymarching_cylinder_getheight;
		sProcAddressMap["libraymarching_cylinder_setheight"] = (void*)&libraymarching_cylinder_setheight;
		sProcAddressMap["libraymarching_quaternionfractal_getquaternion"] = (void*)&libraymarching_quaternionfractal_getquaternion;
		sProcAddressMap["libraymarching_quaternionfractal_setquaternion"] = (void*)&libraymarching_quaternionfractal_setquaternion;
		sProcAddressMap["libraymarching_quaternionfractal_getiterations"] = (void*)&libraymarching_quaternionfractal_getiterations;
		sProcAddressMap["libraymarching_quaternionfractal_setiterations"] = (void*)&libraymarching_quaternionfractal_setiterations;
		sProcAddressMap["libraymarching_mengersponge_getstepcount"] = (void*)&libraymarching_mengersponge_getstepcount;
		sProcAddressMap["libraymarching_mengersponge_setstepcount"] = (void*)&libraymarching_mengersponge_setstepcount;
		sProcAddressMap["libraymarching_primitivegroup_getprimitivecount"] = (void*)&libraymarching_primitivegroup_getprimitivecount;
		sProcAddressMap["libraymarching_primitivegroup_getprimitive"] = (void*)&libraymarching_primitivegroup_getprimitive;
		sProcAddressMap["libraymarching_primitivegroup_addprimitive"] = (void*)&libraymarching_primitivegroup_addprimitive;
		sProcAddressMap["libraymarching_primitivegroup_removeprimitive"] = (void*)&libraymarching_primitivegroup_removeprimitive;
		sProcAddressMap["libraymarching_primitivegroup_setgroupaction"] = (void*)&libraymarching_primitivegroup_setgroupaction;
		sProcAddressMap["libraymarching_primitivegroup_getgroupaction"] = (void*)&libraymarching_primitivegroup_getgroupaction;
		sProcAddressMap["libraymarching_raymarching_getlightcount"] = (void*)&libraymarching_raymarching_getlightcount;
		sProcAddressMap["libraymarching_raymarching_getlight"] = (void*)&libraymarching_raymarching_getlight;
		sProcAddressMap["libraymarching_raymarching_addlight"] = (void*)&libraymarching_raymarching_addlight;
		sProcAddressMap["libraymarching_raymarching_deletelight"] = (void*)&libraymarching_raymarching_deletelight;
		sProcAddressMap["libraymarching_raymarching_getprimitivecount"] = (void*)&libraymarching_raymarching_getprimitivecount;
		sProcAddressMap["libraymarching_raymarching_getprimitive"] = (void*)&libraymarching_raymarching_getprimitive;
		sProcAddressMap["libraymarching_raymarching_addprimitive"] = (void*)&libraymarching_raymarching_addprimitive;
		sProcAddressMap["libraymarching_raymarching_removeprimitive"] = (void*)&libraymarching_raymarching_removeprimitive;
		sProcAddressMap["libraymarching_raymarching_setscreensize"] = (void*)&libraymarching_raymarching_setscreensize;
		sProcAddressMap["libraymarching_raymarching_setviewport"] = (void*)&libraymarching_raymarching_setviewport;
		sProcAddressMap["libraymarching_raymarching_setbackground"] = (void*)&libraymarching_raymarching_setbackground;
		sProcAddressMap["libraymarching_raymarching_setshaderproperties"] = (void*)&libraymarching_raymarching_setshaderproperties;
		sProcAddressMap["libraymarching_raymarching_renderscene"] = (void*)&libraymarching_raymarching_renderscene;
		sProcAddressMap["libraymarching_raymarching_getcolorbuffer"] = (void*)&libraymarching_raymarching_getcolorbuffer;
		sProcAddressMap["libraymarching_raymarching_renderpixel"] = (void*)&libraymarching_raymarching_renderpixel;
		sProcAddressMap["libraymarching_raymarching_setprogresscallback"] = (void*)&libraymarching_raymarching_setprogresscallback;
		sProcAddressMap["libraymarching_getlasterror"] = (void*)&libraymarching_getlasterror;
		sProcAddressMap["libraymarching_getlibraryversion"] = (void*)&libraymarching_getlibraryversion;
		sProcAddressMap["libraymarching_acquireinstance"] = (void*)&libraymarching_acquireinstance;
		sProcAddressMap["libraymarching_releaseinstance"] = (void*)&libraymarching_releaseinstance;
		sProcAddressMap["libraymarching_createraymarching"] = (void*)&libraymarching_createraymarching;
		sProcAddressMap["libraymarching_createsphere"] = (void*)&libraymarching_createsphere;
		sProcAddressMap["libraymarching_createcapsule"] = (void*)&libraymarching_createcapsule;
		sProcAddressMap["libraymarching_createbox"] = (void*)&libraymarching_createbox;
		sProcAddressMap["libraymarching_createplane"] = (void*)&libraymarching_createplane;
		sProcAddressMap["libraymarching_createcylinder"] = (void*)&libraymarching_createcylinder;
		sProcAddressMap["libraymarching_createtorus"] = (void*)&libraymarching_createtorus;
		sProcAddressMap["libraymarching_createmengersponge"] = (void*)&libraymarching_createmengersponge;
		sProcAddressMap["libraymarching_createquaternionfractal"] = (void*)&libraymarching_createquaternionfractal;
		sProcAddressMap["libraymarching_createprimitivegroup"] = (void*)&libraymarching_createprimitivegroup;
		
		sbProcAddressMapHasBeenInitialized = true;
	}
	if (pProcName == nullptr)
		return LIBRAYMARCHING_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBRAYMARCHING_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	auto procPair = sProcAddressMap.find(sProcName);
	if (procPair == sProcAddressMap.end()) {
		return LIBRAYMARCHING_ERROR_COULDNOTFINDLIBRARYEXPORT;
	}
	else {
		*ppProcAddress = procPair->second;
		return LIBRAYMARCHING_SUCCESS;
	}
	
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_getlasterror(LibRayMarching_BaseClass pInstance, const LibRayMarching_uint32 nErrorMessageBufferSize, LibRayMarching_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pIBaseClassInstance = (IBaseClass *)pInstance;
		IBaseClass* pIInstance = dynamic_cast<IBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibRayMarching_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_getlibraryversion(LibRayMarching_uint32 * pMajor, LibRayMarching_uint32 * pMinor, LibRayMarching_uint32 * pMicro)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		CWrapper::GetLibraryVersion(*pMajor, *pMinor, *pMicro);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_acquireinstance(LibRayMarching_BaseClass pInstance)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		IBaseClass* pIBaseClassInstance = (IBaseClass *)pInstance;
		IBaseClass* pIInstance = dynamic_cast<IBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_releaseinstance(LibRayMarching_BaseClass pInstance)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		IBaseClass* pIBaseClassInstance = (IBaseClass *)pInstance;
		IBaseClass* pIInstance = dynamic_cast<IBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createraymarching(LibRayMarching_RayMarching * pInstance)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateRayMarching();

		*pInstance = (IBaseClass*)(pBaseInstance);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createsphere(LibRayMarching_double dRadius, LibRayMarching_Sphere * pSphere)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pSphere == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseSphere(nullptr);
		pBaseSphere = CWrapper::CreateSphere(dRadius);

		*pSphere = (IBaseClass*)(pBaseSphere);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createcapsule(LibRayMarching_double dRadius, const sLibRayMarchingVector * pPoint1, const sLibRayMarchingVector * pPoint2, LibRayMarching_Capsule * pCapsule)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pCapsule == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseCapsule(nullptr);
		pBaseCapsule = CWrapper::CreateCapsule(dRadius, *pPoint1, *pPoint2);

		*pCapsule = (IBaseClass*)(pBaseCapsule);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createbox(const sLibRayMarchingVector * pDimensions, LibRayMarching_Box * pBox)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pBox == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseBox(nullptr);
		pBaseBox = CWrapper::CreateBox(*pDimensions);

		*pBox = (IBaseClass*)(pBaseBox);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createplane(const sLibRayMarchingVector * pOrigin, const sLibRayMarchingVector * pNormal, LibRayMarching_Plane * pPlane)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pPlane == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBasePlane(nullptr);
		pBasePlane = CWrapper::CreatePlane(*pOrigin, *pNormal);

		*pPlane = (IBaseClass*)(pBasePlane);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createcylinder(LibRayMarching_double dRadius, LibRayMarching_double dHeight, LibRayMarching_Cylinder * pCylinder)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pCylinder == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseCylinder(nullptr);
		pBaseCylinder = CWrapper::CreateCylinder(dRadius, dHeight);

		*pCylinder = (IBaseClass*)(pBaseCylinder);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createtorus(LibRayMarching_double dBigRadius, LibRayMarching_double dSmallRadius, LibRayMarching_Torus * pTorus)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pTorus == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseTorus(nullptr);
		pBaseTorus = CWrapper::CreateTorus(dBigRadius, dSmallRadius);

		*pTorus = (IBaseClass*)(pBaseTorus);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createmengersponge(LibRayMarching_uint32 nStepCount, LibRayMarching_MengerSponge * pMengerSponge)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pMengerSponge == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseMengerSponge(nullptr);
		pBaseMengerSponge = CWrapper::CreateMengerSponge(nStepCount);

		*pMengerSponge = (IBaseClass*)(pBaseMengerSponge);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createquaternionfractal(LibRayMarching_uint32 nIterations, LibRayMarching_QuaternionFractal * pQuaternionFractal)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pQuaternionFractal == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBaseQuaternionFractal(nullptr);
		pBaseQuaternionFractal = CWrapper::CreateQuaternionFractal(nIterations);

		*pQuaternionFractal = (IBaseClass*)(pBaseQuaternionFractal);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createprimitivegroup(eLibRayMarchingGroupAction eGroupAction, LibRayMarching_PrimitiveGroup * pPrimitiveGroup)
{
	IBaseClass* pIBaseClass = nullptr;

	try {
		if (pPrimitiveGroup == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		IBaseClass* pBasePrimitiveGroup(nullptr);
		pBasePrimitiveGroup = CWrapper::CreatePrimitiveGroup(eGroupAction);

		*pPrimitiveGroup = (IBaseClass*)(pBasePrimitiveGroup);
		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


