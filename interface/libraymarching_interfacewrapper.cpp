/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.5.0.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Ray Marching Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 0.9.0

*/

#include "libraymarching.h"
#include "libraymarching_interfaces.hpp"
#include "libraymarching_interfaceexception.hpp"

using namespace LibRayMarching::Impl;

LibRayMarchingResult handleLibRayMarchingException(ILibRayMarchingBaseClass * pIBaseClass, ELibRayMarchingInterfaceException & Exception)
{
	LibRayMarchingResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRayMarchingResult handleStdException(ILibRayMarchingBaseClass * pIBaseClass, std::exception & Exception)
{
	LibRayMarchingResult errorCode = LIBRAYMARCHING_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRayMarchingResult handleUnhandledException(ILibRayMarchingBaseClass * pIBaseClass)
{
	LibRayMarchingResult errorCode = LIBRAYMARCHING_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for BaseClass
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Primitive
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_primitive_identityposition (LibRayMarching_Primitive pPrimitive)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->IdentityPosition();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_translate (LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pTranslation)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->Translate(*pTranslation);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_rotate (LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pAxis, LibRayMarching_double dRadian)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->Rotate(*pAxis, dRadian);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_scale (LibRayMarching_Primitive pPrimitive, const sLibRayMarchingVector * pScale)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->Scale(*pScale);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_setmaterial (LibRayMarching_Primitive pPrimitive, const sLibRayMarchingMaterial * pMaterial)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->SetMaterial(*pMaterial);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitive_setsinusdistortion (LibRayMarching_Primitive pPrimitive, LibRayMarching_double dDistortionFactor, LibRayMarching_double dInterval)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitive;

	try {

		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClass);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitive->SetSinusDistortion(dDistortionFactor, dInterval);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Sphere
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_sphere_getradius (LibRayMarching_Sphere pSphere, LibRayMarching_double * pRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pSphere;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingSphere* pISphere = dynamic_cast<ILibRayMarchingSphere*>(pIBaseClass);
		if (!pISphere)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pRadius = pISphere->GetRadius();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_sphere_setradius (LibRayMarching_Sphere pSphere, LibRayMarching_double dRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pSphere;

	try {

		ILibRayMarchingSphere* pISphere = dynamic_cast<ILibRayMarchingSphere*>(pIBaseClass);
		if (!pISphere)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pISphere->SetRadius(dRadius);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Capsule
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_capsule_getradius (LibRayMarching_Capsule pCapsule, LibRayMarching_double * pRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pRadius = pICapsule->GetRadius();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setradius (LibRayMarching_Capsule pCapsule, LibRayMarching_double dRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pICapsule->SetRadius(dRadius);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_getpoint1 (LibRayMarching_Capsule pCapsule, sLibRayMarchingVector * pPoint1)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {
		if (pPoint1 == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pPoint1 = pICapsule->GetPoint1();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setpoint1 (LibRayMarching_Capsule pCapsule, const sLibRayMarchingVector * pPoint1)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pICapsule->SetPoint1(*pPoint1);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_getpoint2 (LibRayMarching_Capsule pCapsule, sLibRayMarchingVector * pPoint2)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {
		if (pPoint2 == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pPoint2 = pICapsule->GetPoint2();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_capsule_setpoint2 (LibRayMarching_Capsule pCapsule, const sLibRayMarchingVector * pPoint2)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCapsule;

	try {

		ILibRayMarchingCapsule* pICapsule = dynamic_cast<ILibRayMarchingCapsule*>(pIBaseClass);
		if (!pICapsule)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pICapsule->SetPoint2(*pPoint2);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Plane
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_plane_getnormal (LibRayMarching_Plane pPlane, sLibRayMarchingVector * pNormal)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPlane;

	try {
		if (pNormal == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingPlane* pIPlane = dynamic_cast<ILibRayMarchingPlane*>(pIBaseClass);
		if (!pIPlane)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pNormal = pIPlane->GetNormal();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_plane_setnormal (LibRayMarching_Plane pPlane, const sLibRayMarchingVector * pNormal)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPlane;

	try {

		ILibRayMarchingPlane* pIPlane = dynamic_cast<ILibRayMarchingPlane*>(pIBaseClass);
		if (!pIPlane)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPlane->SetNormal(*pNormal);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Box
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_box_getdimensions (LibRayMarching_Box pBox, sLibRayMarchingVector * pDimensions)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pBox;

	try {
		if (pDimensions == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBox* pIBox = dynamic_cast<ILibRayMarchingBox*>(pIBaseClass);
		if (!pIBox)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pDimensions = pIBox->GetDimensions();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_box_setdimensions (LibRayMarching_Box pBox, const sLibRayMarchingVector * pDimensions)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pBox;

	try {

		ILibRayMarchingBox* pIBox = dynamic_cast<ILibRayMarchingBox*>(pIBaseClass);
		if (!pIBox)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIBox->SetDimensions(*pDimensions);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Torus
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_torus_getbigradius (LibRayMarching_Torus pTorus, LibRayMarching_double * pBigRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pTorus;

	try {
		if (pBigRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingTorus* pITorus = dynamic_cast<ILibRayMarchingTorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pBigRadius = pITorus->GetBigRadius();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_setbigradius (LibRayMarching_Torus pTorus, LibRayMarching_double dBigRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pTorus;

	try {

		ILibRayMarchingTorus* pITorus = dynamic_cast<ILibRayMarchingTorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pITorus->SetBigRadius(dBigRadius);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_getsmallradius (LibRayMarching_Torus pTorus, LibRayMarching_double * pSmallRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pTorus;

	try {
		if (pSmallRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingTorus* pITorus = dynamic_cast<ILibRayMarchingTorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pSmallRadius = pITorus->GetSmallRadius();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_torus_setsmallradius (LibRayMarching_Torus pTorus, LibRayMarching_double dSmallRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pTorus;

	try {

		ILibRayMarchingTorus* pITorus = dynamic_cast<ILibRayMarchingTorus*>(pIBaseClass);
		if (!pITorus)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pITorus->SetSmallRadius(dSmallRadius);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Cylinder
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_cylinder_getradius (LibRayMarching_Cylinder pCylinder, LibRayMarching_double * pRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCylinder;

	try {
		if (pRadius == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingCylinder* pICylinder = dynamic_cast<ILibRayMarchingCylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pRadius = pICylinder->GetRadius();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_setradius (LibRayMarching_Cylinder pCylinder, LibRayMarching_double dRadius)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCylinder;

	try {

		ILibRayMarchingCylinder* pICylinder = dynamic_cast<ILibRayMarchingCylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pICylinder->SetRadius(dRadius);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_getheight (LibRayMarching_Cylinder pCylinder, LibRayMarching_double * pHeight)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCylinder;

	try {
		if (pHeight == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingCylinder* pICylinder = dynamic_cast<ILibRayMarchingCylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pHeight = pICylinder->GetHeight();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_cylinder_setheight (LibRayMarching_Cylinder pCylinder, LibRayMarching_double dHeight)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pCylinder;

	try {

		ILibRayMarchingCylinder* pICylinder = dynamic_cast<ILibRayMarchingCylinder*>(pIBaseClass);
		if (!pICylinder)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pICylinder->SetHeight(dHeight);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for QuaternionFractal
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_quaternionfractal_getquaternion (LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_double * pR, LibRayMarching_double * pI, LibRayMarching_double * pJ, LibRayMarching_double * pK)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pQuaternionFractal;

	try {
		if (!pR)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pI)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pJ)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pK)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingQuaternionFractal* pIQuaternionFractal = dynamic_cast<ILibRayMarchingQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIQuaternionFractal->GetQuaternion(*pR, *pI, *pJ, *pK);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_setquaternion (LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_double dR, LibRayMarching_double dI, LibRayMarching_double dJ, LibRayMarching_double dK)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pQuaternionFractal;

	try {

		ILibRayMarchingQuaternionFractal* pIQuaternionFractal = dynamic_cast<ILibRayMarchingQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIQuaternionFractal->SetQuaternion(dR, dI, dJ, dK);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_getiterations (LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_uint32 * pIterations)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pQuaternionFractal;

	try {
		if (pIterations == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingQuaternionFractal* pIQuaternionFractal = dynamic_cast<ILibRayMarchingQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pIterations = pIQuaternionFractal->GetIterations();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_quaternionfractal_setiterations (LibRayMarching_QuaternionFractal pQuaternionFractal, LibRayMarching_uint32 nIterations)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pQuaternionFractal;

	try {

		ILibRayMarchingQuaternionFractal* pIQuaternionFractal = dynamic_cast<ILibRayMarchingQuaternionFractal*>(pIBaseClass);
		if (!pIQuaternionFractal)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIQuaternionFractal->SetIterations(nIterations);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for MengerSponge
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_mengersponge_getstepcount (LibRayMarching_MengerSponge pMengerSponge, LibRayMarching_uint32 * pStepCount)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pMengerSponge;

	try {
		if (pStepCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingMengerSponge* pIMengerSponge = dynamic_cast<ILibRayMarchingMengerSponge*>(pIBaseClass);
		if (!pIMengerSponge)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pStepCount = pIMengerSponge->GetStepCount();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_mengersponge_setstepcount (LibRayMarching_MengerSponge pMengerSponge, LibRayMarching_uint32 nStepCount)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pMengerSponge;

	try {

		ILibRayMarchingMengerSponge* pIMengerSponge = dynamic_cast<ILibRayMarchingMengerSponge*>(pIBaseClass);
		if (!pIMengerSponge)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIMengerSponge->SetStepCount(nStepCount);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PrimitiveGroup
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_primitivegroup_getprimitivecount (LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 * pCount)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pCount = pIPrimitiveGroup->GetPrimitiveCount();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_getprimitive (LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 nIndex, LibRayMarching_Primitive * pPrimitive)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {
		if (pPrimitive == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);

		ILibRayMarchingBaseClass* pBasePrimitive(nullptr);

		pBasePrimitive = pIPrimitiveGroup->GetPrimitive(nIndex);

		*pPrimitive = (ILibRayMarchingBaseClass*)(pBasePrimitive);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_addprimitive (LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_Primitive pPrimitive)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);

		ILibRayMarchingBaseClass* pIBaseClassPrimitive = (ILibRayMarchingBaseClass *)pPrimitive;
		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClassPrimitive);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitiveGroup->AddPrimitive(pIPrimitive);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_removeprimitive (LibRayMarching_PrimitiveGroup pPrimitiveGroup, LibRayMarching_uint32 nIndex)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitiveGroup->RemovePrimitive(nIndex);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_setgroupaction (LibRayMarching_PrimitiveGroup pPrimitiveGroup, eLibRayMarchingGroupAction eGroupAction)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIPrimitiveGroup->SetGroupAction(eGroupAction);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_primitivegroup_getgroupaction (LibRayMarching_PrimitiveGroup pPrimitiveGroup, eLibRayMarchingGroupAction * pGroupAction)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pPrimitiveGroup;

	try {
		if (pGroupAction == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingPrimitiveGroup* pIPrimitiveGroup = dynamic_cast<ILibRayMarchingPrimitiveGroup*>(pIBaseClass);
		if (!pIPrimitiveGroup)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pGroupAction = pIPrimitiveGroup->GetGroupAction();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for RayMarching
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_raymarching_getlightcount (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 * pCount)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pCount = pIRayMarching->GetLightCount();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getlight (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex, sLibRayMarchingVector * pPosition, sLibRayMarchingVector * pColor)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if (!pPosition)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pColor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->GetLight(nIndex, *pPosition, *pColor);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_addlight (LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingVector * pPosition, const sLibRayMarchingVector * pColor)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->AddLight(*pPosition, *pColor);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_deletelight (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->DeleteLight(nIndex);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getprimitivecount (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 * pCount)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if (pCount == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pCount = pIRayMarching->GetPrimitiveCount();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getprimitive (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex, LibRayMarching_Primitive * pPrimitive)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if (pPrimitive == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);

		ILibRayMarchingBaseClass* pBasePrimitive(nullptr);

		pBasePrimitive = pIRayMarching->GetPrimitive(nIndex);

		*pPrimitive = (ILibRayMarchingBaseClass*)(pBasePrimitive);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_addprimitive (LibRayMarching_RayMarching pRayMarching, LibRayMarching_Primitive pPrimitive)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);

		ILibRayMarchingBaseClass* pIBaseClassPrimitive = (ILibRayMarchingBaseClass *)pPrimitive;
		ILibRayMarchingPrimitive* pIPrimitive = dynamic_cast<ILibRayMarchingPrimitive*>(pIBaseClassPrimitive);
		if (!pIPrimitive)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->AddPrimitive(pIPrimitive);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_removeprimitive (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nIndex)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->RemovePrimitive(nIndex);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setscreensize (LibRayMarching_RayMarching pRayMarching, LibRayMarching_uint32 nWidth, LibRayMarching_uint32 nHeight)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->SetScreenSize(nWidth, nHeight);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setviewport (LibRayMarching_RayMarching pRayMarching, const sLibRayMarchingVector * pEye, const sLibRayMarchingVector * pDir, const sLibRayMarchingVector * pUp, LibRayMarching_double dFOV)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->SetViewport(*pEye, *pDir, *pUp, dFOV);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_renderscene (LibRayMarching_RayMarching pRayMarching)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->RenderScene();


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_getcolorbuffer (LibRayMarching_RayMarching pRayMarching, const LibRayMarching_uint64 nColorBufferBufferSize, LibRayMarching_uint64* pColorBufferNeededCount, LibRayMarching_uint64 * pColorBufferBuffer)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if ((!pColorBufferBuffer) && !(pColorBufferNeededCount))
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->GetColorBuffer(nColorBufferBufferSize, pColorBufferNeededCount, pColorBufferBuffer);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_renderpixel (LibRayMarching_RayMarching pRayMarching, LibRayMarching_double dX, LibRayMarching_double dY, LibRayMarching_uint32 * pColor)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {
		if (pColor == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		*pColor = pIRayMarching->RenderPixel(dX, dY);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_raymarching_setprogresscallback (LibRayMarching_RayMarching pRayMarching, LibRayMarchingProgressCallback pProgressCallback)
{
	ILibRayMarchingBaseClass* pIBaseClass = (ILibRayMarchingBaseClass *)pRayMarching;

	try {

		ILibRayMarchingRayMarching* pIRayMarching = dynamic_cast<ILibRayMarchingRayMarching*>(pIBaseClass);
		if (!pIRayMarching)
			throw ELibRayMarchingInterfaceException(LIBRAYMARCHING_ERROR_INVALIDCAST);


		pIRayMarching->SetProgressCallback(pProgressCallback);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibRayMarchingResult libraymarching_getlasterror (LibRayMarching_BaseClass pInstance, const LibRayMarching_uint32 nErrorMessageBufferSize, LibRayMarching_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pIBaseClassInstance = (ILibRayMarchingBaseClass *)pInstance;
		ILibRayMarchingBaseClass* pIInstance = dynamic_cast<ILibRayMarchingBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);

		std::string sErrorMessage("");

		*pHasError = CLibRayMarchingWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars) 
			*pErrorMessageNeededChars = (LibRayMarching_uint32) sErrorMessage.size();
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_BUFFERTOOSMALL);
			for (int iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
		}

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_releaseinstance (LibRayMarching_BaseClass pInstance)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {

		ILibRayMarchingBaseClass* pIBaseClassInstance = (ILibRayMarchingBaseClass *)pInstance;
		ILibRayMarchingBaseClass* pIInstance = dynamic_cast<ILibRayMarchingBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDCAST);


		CLibRayMarchingWrapper::ReleaseInstance(pIInstance);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_getlibraryversion (LibRayMarching_uint32 * pMajor, LibRayMarching_uint32 * pMinor, LibRayMarching_uint32 * pMicro)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);


		CLibRayMarchingWrapper::GetLibraryVersion(*pMajor, *pMinor, *pMicro);


		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createraymarching (LibRayMarching_RayMarching * pInstance)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseInstance(nullptr);

		pBaseInstance = CLibRayMarchingWrapper::CreateRayMarching();

		*pInstance = (ILibRayMarchingBaseClass*)(pBaseInstance);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createsphere (LibRayMarching_double dRadius, LibRayMarching_Sphere * pSphere)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pSphere == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseSphere(nullptr);

		pBaseSphere = CLibRayMarchingWrapper::CreateSphere(dRadius);

		*pSphere = (ILibRayMarchingBaseClass*)(pBaseSphere);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createcapsule (LibRayMarching_double dRadius, const sLibRayMarchingVector * pPoint1, const sLibRayMarchingVector * pPoint2, LibRayMarching_Capsule * pCapsule)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pCapsule == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseCapsule(nullptr);

		pBaseCapsule = CLibRayMarchingWrapper::CreateCapsule(dRadius, *pPoint1, *pPoint2);

		*pCapsule = (ILibRayMarchingBaseClass*)(pBaseCapsule);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createbox (const sLibRayMarchingVector * pDimensions, LibRayMarching_Box * pBox)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pBox == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseBox(nullptr);

		pBaseBox = CLibRayMarchingWrapper::CreateBox(*pDimensions);

		*pBox = (ILibRayMarchingBaseClass*)(pBaseBox);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createplane (const sLibRayMarchingVector * pOrigin, const sLibRayMarchingVector * pNormal, LibRayMarching_Plane * pPlane)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pPlane == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBasePlane(nullptr);

		pBasePlane = CLibRayMarchingWrapper::CreatePlane(*pOrigin, *pNormal);

		*pPlane = (ILibRayMarchingBaseClass*)(pBasePlane);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createcylinder (LibRayMarching_double dRadius, LibRayMarching_double dHeight, LibRayMarching_Cylinder * pCylinder)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pCylinder == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseCylinder(nullptr);

		pBaseCylinder = CLibRayMarchingWrapper::CreateCylinder(dRadius, dHeight);

		*pCylinder = (ILibRayMarchingBaseClass*)(pBaseCylinder);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createtorus (LibRayMarching_double dBigRadius, LibRayMarching_double dSmallRadius, LibRayMarching_Torus * pTorus)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pTorus == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseTorus(nullptr);

		pBaseTorus = CLibRayMarchingWrapper::CreateTorus(dBigRadius, dSmallRadius);

		*pTorus = (ILibRayMarchingBaseClass*)(pBaseTorus);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createmengersponge (LibRayMarching_uint32 nStepCount, LibRayMarching_MengerSponge * pMengerSponge)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pMengerSponge == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseMengerSponge(nullptr);

		pBaseMengerSponge = CLibRayMarchingWrapper::CreateMengerSponge(nStepCount);

		*pMengerSponge = (ILibRayMarchingBaseClass*)(pBaseMengerSponge);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createquaternionfractal (LibRayMarching_uint32 nIterations, LibRayMarching_QuaternionFractal * pQuaternionFractal)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pQuaternionFractal == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBaseQuaternionFractal(nullptr);

		pBaseQuaternionFractal = CLibRayMarchingWrapper::CreateQuaternionFractal(nIterations);

		*pQuaternionFractal = (ILibRayMarchingBaseClass*)(pBaseQuaternionFractal);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRayMarchingResult libraymarching_createprimitivegroup (eLibRayMarchingGroupAction eGroupAction, LibRayMarching_PrimitiveGroup * pPrimitiveGroup)
{
	ILibRayMarchingBaseClass* pIBaseClass = nullptr;

	try {
		if (pPrimitiveGroup == nullptr)
			throw ELibRayMarchingInterfaceException (LIBRAYMARCHING_ERROR_INVALIDPARAM);

		ILibRayMarchingBaseClass* pBasePrimitiveGroup(nullptr);

		pBasePrimitiveGroup = CLibRayMarchingWrapper::CreatePrimitiveGroup(eGroupAction);

		*pPrimitiveGroup = (ILibRayMarchingBaseClass*)(pBasePrimitiveGroup);

		return LIBRAYMARCHING_SUCCESS;
	}
	catch (ELibRayMarchingInterfaceException & Exception) {
		return handleLibRayMarchingException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


