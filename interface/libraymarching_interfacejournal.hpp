/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.4.0.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of Ray Marching Library. It provides an automatic Journaling mechanism for the library implementation.

Interface version: 0.9.0

*/

#ifndef __LIBRAYMARCHING_INTERFACEJOURNAL_HEADER
#define __LIBRAYMARCHING_INTERFACEJOURNAL_HEADER

#include <iostream>
#include <fstream>
#include <string>
#include <memory>
#include <list>
#include <mutex>
#include <chrono>
#include "libraymarching_types.h"

/*************************************************************************************************************************
 Class CLibRayMarchingInterfaceJournal 
**************************************************************************************************************************/

class CLibRayMarchingInterfaceJournal;

class CLibRayMarchingInterfaceJournalEntry {

	protected:

		CLibRayMarchingInterfaceJournal * m_pJournal;
		LibRayMarchingResult m_ErrorCode;
		std::string m_sClassName;
		std::string m_sMethodName;
		std::string m_sInstanceHandle;
		LibRayMarching_uint64 m_nInitTimeStamp;
		LibRayMarching_uint64 m_nFinishTimeStamp;
		std::list<std::pair<std::pair<std::string, std::string>, std::string>> m_sParameters;
		std::list<std::pair<std::pair<std::string, std::string>, std::string>> m_sResultValues;

		std::string getXMLString();
		void addParameter (const std::string & sName, const std::string & sParameterType, const std::string & sParameterValue);
		void addResult (const std::string & sName, const std::string & sResultType, const std::string & sResultValue);

	public:
		CLibRayMarchingInterfaceJournalEntry(CLibRayMarchingInterfaceJournal * pJournal, std::string sClassName, std::string sMethodName, LibRayMarchingHandle pInstanceHandle);
		~CLibRayMarchingInterfaceJournalEntry();

		void writeSuccess ();
		void writeError (LibRayMarchingResult nErrorCode);

		void addBooleanParameter(const std::string & sName, const bool bValue);
		void addUInt8Parameter(const std::string & sName, const LibRayMarching_uint8 nValue);
		void addUInt16Parameter(const std::string & sName, const LibRayMarching_uint16 nValue);
		void addUInt32Parameter(const std::string & sName, const LibRayMarching_uint32 nValue);
		void addUInt64Parameter(const std::string & sName, const LibRayMarching_uint64 nValue);
		void addInt8Parameter(const std::string & sName, const LibRayMarching_int8 nValue);
		void addInt16Parameter(const std::string & sName, const LibRayMarching_int16 nValue);
		void addInt32Parameter(const std::string & sName, const LibRayMarching_int32 nValue);
		void addInt64Parameter(const std::string & sName, const LibRayMarching_int64 nValue);
		void addSingleParameter(const std::string & sName, const LibRayMarching_single fValue);
		void addDoubleParameter(const std::string & sName, const LibRayMarching_double dValue);
		void addStringParameter(const std::string & sName, const char * pValue);
		void addHandleParameter(const std::string & sName, const LibRayMarchingHandle pHandle);
		void addEnumParameter(const std::string & sName, const std::string & sEnumType, const LibRayMarching_uint32 nValue);

		void addBooleanResult(const std::string & sName, const bool bValue);
		void addUInt8Result(const std::string & sName, const LibRayMarching_uint8 nValue);
		void addUInt16Result(const std::string & sName, const LibRayMarching_uint16 nValue);
		void addUInt32Result(const std::string & sName, const LibRayMarching_uint32 nValue);
		void addUInt64Result(const std::string & sName, const LibRayMarching_uint64 nValue);
		void addInt8Result(const std::string & sName, const LibRayMarching_int8 nValue);
		void addInt16Result(const std::string & sName, const LibRayMarching_int16 nValue);
		void addInt32Result(const std::string & sName, const LibRayMarching_int32 nValue);
		void addInt64Result(const std::string & sName, const LibRayMarching_int64 nValue);
		void addSingleResult(const std::string & sName, const LibRayMarching_single fValue);
		void addDoubleResult(const std::string & sName, const LibRayMarching_double dValue);
		void addStringResult(const std::string & sName, const char * pValue);
		void addHandleResult(const std::string & sName, const LibRayMarchingHandle pHandle);
		void addEnumResult(const std::string & sName, const std::string & sEnumType, const LibRayMarching_uint32 nValue);

friend class CLibRayMarchingInterfaceJournal;

};

typedef std::shared_ptr<CLibRayMarchingInterfaceJournalEntry> PLibRayMarchingInterfaceJournalEntry;



class CLibRayMarchingInterfaceJournal {

	protected:

		std::string m_sFileName;
		std::mutex m_Mutex;
		std::ofstream m_Stream;
		std::chrono::time_point<std::chrono::high_resolution_clock> m_StartTime;
		void writeEntry (CLibRayMarchingInterfaceJournalEntry * pEntry);
		LibRayMarching_uint64 getTimeStamp ();

	public:

		CLibRayMarchingInterfaceJournal (const std::string & sFileName);
		~CLibRayMarchingInterfaceJournal ();
		PLibRayMarchingInterfaceJournalEntry beginClassMethod (const LibRayMarchingHandle pHandle, const std::string & sClassName, const std::string & sMethodName);
		PLibRayMarchingInterfaceJournalEntry beginStaticFunction (const std::string & sMethodName);
		friend class CLibRayMarchingInterfaceJournalEntry;
};

typedef std::shared_ptr<CLibRayMarchingInterfaceJournal> PLibRayMarchingInterfaceJournal;

#endif // __LIBRAYMARCHING_INTERFACEJOURNAL_HEADER

